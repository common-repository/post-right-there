// Generated by CoffeeScript 1.10.0
(function() {
  var addListener, ancestor, arrayToOdjectSet, bindFileInputToImg, bindFileInputToLink, checkBoxListGet, checkBoxListSet, checkBoxesGetBooleans, checkBoxesSetBooleans, checkBoxesSetBooleansUpdate, clone, descendant, descendants, doCreate, extend, fillSelectOptions, findParent, getModel, hasProp, initModel, merge, modelToTree, parse, selectListGet, selectListSet, setModel, setUpListeners, val,
    hasProp1 = {}.hasOwnProperty;

  hasProp = {}.hasOwnProperty;

  merge = function(options, defaults) {
    var key;
    if (typeof defaults === "undefined" || defaults === null) {
      defaults = {};
    }
    if (typeof options === "undefined" || options === null) {
      return defaults;
    }
    console.log(options);
    console.log(defaults);
    key = null;
    for (key in defaults) {
      if (!hasProp1.call(defaults, key)) continue;
      console.log(key);
      options[key] = hasProp(options, key) ? options[key] : defaults[key];
    }
    return options;
  };

  extend = function(object, properties) {
    var key, val;
    for (key in properties) {
      if (!hasProp1.call(properties, key)) continue;
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  arrayToOdjectSet = function(arr) {
    var k, len, obj, val;
    obj = {};
    for (k = 0, len = arr.length; k < len; k++) {
      val = arr[k];
      obj[val] = true;
    }
    return obj;
  };

  ancestor = typeof Element.prototype.closest === 'function' ? function(elem, selector) {
    return elem.closest(selector);
  } : function(elem, selector) {
    var par;
    par = jQuery(elem).parents(selector);
    if (par.length > 0) {
      return par[0];
    } else {
      return null;
    }
  };

  descendants = typeof Element.prototype.querySelectorAll === 'function' ? function(elem, selector) {
    return elem.querySelectorAll(selector);
  } : function(elem, selector) {
    return jQuery(elem).find(selector);
  };

  descendant = typeof Element.prototype.querySelector === 'function' ? function(elem, selector) {
    return elem.querySelector(selector);
  } : function(elem, selector) {
    var des;
    des = jQuery(elem).find(selector);
    if (des.length > 0) {
      return des[0];
    } else {
      return null;
    }
  };

  val = function(elem, val) {
    if (arguments.length > 1) {
      if (elem.tagName.toUpperCase() === "IMG") {
        if (val) {
          return elem.src = val;
        } else {
          return elem.removeAttribute('src');
        }
      } else if (elem.tagName.toUpperCase() === "A") {
        if (val) {
          elem.href = val;
          return elem.innerHTML = val.replace(/^http(s)?:\/\//, "");
        } else {
          elem.removeAttribute('href');
          return elem.innerHTML = null;
        }
      } else if (elem.tagName.toUpperCase() === "INPUT" && elem.getAttribute('type') === "checkbox") {
        return elem.checked = !!val;
      } else if (elem.tagName.toUpperCase() === "DIV" || elem.tagName.toUpperCase() === "SPAN") {
        if (val) {
          return elem.innerHTML = val;
        } else {
          return elem.innerHTML = null;
        }
      } else {
        return jQuery(elem).val(val);
      }
    } else {
      if (elem.tagName.toUpperCase() === "IMG") {
        return elem.src;
      } else if (elem.tagName.toUpperCase() === "A") {
        return elem.href;
      } else if (elem.tagName.toUpperCase() === "INPUT" && elem.getAttribute('type') === "checkbox") {
        return elem.checked;
      } else if (elem.tagName.toUpperCase() === "DIV" || elem.tagName.toUpperCase() === "SPAN") {
        return elem.innerHTML;
      } else {
        return jQuery(elem).val();
      }
    }
  };

  addListener = function(elem, trigger, data, callback) {
    console.log(arguments);
    return jQuery(elem).on(trigger, null, data, callback);
  };

  parse = function(s) {
    var automaton, err, error, i, k, marker, preprocessed, ref, state;
    preprocessed = '{';
    marker = 0;
    state = "IN_SPACE";
    automaton = {
      IN_SPACE: function(pos, char) {
        if (char === "'") {
          state = "IN_SINGLE_QUOTED";
          return preprocessed += '"';
        } else if (char === '"') {
          state = "IN_DOUBLE_QUOTED";
          return preprocessed += '"';
        } else if (/\w|[-.+]/.test(char)) {
          state = "IN_UNQUOTED";
          return marker = pos;
        } else if (/[:{}\[\],]/.test(char)) {
          return preprocessed += char;
        } else if (!/\s/.test(char)) {
          throw new Error("vf: unexpected character " + char + " at " + pos + " in " + s);
        }
      },
      IN_DOUBLE_QUOTED: function(pos, char) {
        if (char === '"') {
          state = "IN_SPACE";
          return preprocessed += '"';
        } else if (char === '\\') {
          state = "IN_ESCAPE_DOUBLE";
          return preprocessed += '\\';
        } else {
          return preprocessed += char;
        }
      },
      IN_SINGLE_QUOTED: function(pos, char) {
        if (char === "'") {
          state = "IN_SPACE";
          return preprocessed += '"';
        } else if (char === '"') {
          return preprocessed += '\\"';
        } else if (char === '\\') {
          state = "IN_ESCAPE_SINGLE";
          return preprocessed += '\\';
        } else {
          return preprocessed += char;
        }
      },
      IN_ESCAPE_DOUBLE: function(pos, char) {
        state = "IN_DOUBLE_QUOTED";
        return preprocessed += char;
      },
      IN_ESCAPE_SINGLE: function(pos, char) {
        state = "IN_SINGLE_QUOTED";
        return preprocessed += char;
      },
      IN_UNQUOTED: function(pos, char) {
        var endOfInput, endOfToken, part;
        endOfInput = pos === s.length - 1;
        endOfToken = !/\w|[-.+]/.test(char);
        if (endOfToken || endOfInput) {
          part = s.substring(marker, !endOfToken ? pos + 1 : pos);
          if (part !== "true" && part !== "false" && part !== "null" && !/^\d+(\.\d+)?([eE][+-]?\d+)?$/.test(part)) {
            preprocessed += '"' + part + '"';
          } else {
            preprocessed += part;
          }
          state = "IN_SPACE";
          if (endOfToken) {
            return automaton.IN_SPACE(pos, char);
          }
        }
      }
    };
    for (i = k = 0, ref = s.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      automaton[state](i, s.charAt(i));
    }
    preprocessed += "}";
    try {
      return JSON.parse(preprocessed);
    } catch (error) {
      err = error;
      console.log('vf: could not parse: ' + s);
      throw new Error(err);
    }
  };

  clone = function(elem, isDeep) {
    return jQuery(elem).clone(isDeep)[0];
  };

  findParent = function(elem, parentName, root) {
    var current;
    current = elem.parentNode;
    while ((current != null) && current !== root) {
      if ((current.vfModel != null) && (current.vfModel.object === parentName || current.vfModel.list === parentName)) {
        return current;
      }
      current = current.parentNode;
    }
    return null;
  };

  initModel = function(item) {
    var vfModel;
    vfModel = parse(item.getAttribute("vf-model"));
    item.vfModel = vfModel;
    if (vfModel.atom != null) {
      vfModel.val = vfModel.getter != null ? eval(vfModel.getter).call(null, item) : val(item);
      vfModel.name = vfModel.atom;
    }
    if (vfModel.object != null) {
      vfModel.val = {};
      vfModel.name = vfModel.object;
    }
    if (vfModel.list != null) {
      vfModel.val = [];
      vfModel.name = vfModel.list;
    }
    return vfModel;
  };

  getModel = function(elem, model) {
    var ances, ancestorNames, i, item, items, k, l, len, parent, parentIsList, ref, rootName, vfModel;
    rootName = elem.getAttribute("vf-model");
    rootName = rootName != null ? parse(rootName) : null;
    rootName = rootName != null ? rootName.object : void 0;
    if (model == null) {
      model = {};
    }
    items = descendants(elem, "[vf-model]");
    for (i = k = 0, ref = items.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      item = items[i];
      vfModel = initModel(item);
      if (item.hasAttribute("vf-exclude")) {
        continue;
      }
      if (((vfModel.parent != null) && vfModel.parent !== rootName) || (vfModel.ancestors != null) || (vfModel.ancestorsList != null)) {
        if (vfModel.parent != null) {
          parent = findParent(item, vfModel.parent, elem);
          if (parent == null) {
            console.log(item);
            throw new Error("could not find parent " + vfModel.parent + " of " + vfModel.name);
          }
          parentIsList = parent.vfModel.list != null;
          parent = parent.vfModel.val;
        } else {
          parentIsList = vfModel.list != null;
          ancestorNames = vfModel.ancestors || vfModel.ancestorsList;
          parent = model;
          for (i = l = 0, len = ancestorNames.length; l < len; i = ++l) {
            ances = ancestorNames[i];
            if (parent[ances] != null) {
              parent = parent[ances];
            } else {
              parent = parent[ances] = parentIsList && i === ancestorNames.lenght - 1 ? [] : {};
            }
          }
        }
        if (parentIsList) {
          parent.push(vfModel.val);
        } else {
          if (parent[vfModel.name] != null) {
            merge(vfModel.val, parent[vfModel.name]);
          }
          parent[vfModel.name] = vfModel.val;
        }
      } else {
        if (model[vfModel.name] != null) {
          merge(vfModel.val, model[vfModel.name]);
        }
        model[vfModel.name] = vfModel.val;
      }
    }
    return model;
  };

  modelToTree = function(model, treeRoot) {
    var child, key, value;
    if (typeof model === "string") {
      return treeRoot;
    }
    treeRoot.children = {};
    for (key in model) {
      if (!hasProp1.call(model, key)) continue;
      value = model[key];
      child = {
        parent: treeRoot,
        name: key,
        value: value
      };
      treeRoot.children[key] = child;
      modelToTree(value, child);
    }
    return treeRoot;
  };

  setModel = function(elem, model) {
    var ances, ancestorNames, childVal, domRoot, elemToClear, elemsToClear, i, item, itemElem, items, k, l, len, len1, m, parent, ref, ref1, results, root, rootName, templ, tree, value, vfModel;
    rootName = elem.getAttribute("vf-model");
    rootName = rootName != null ? parse(rootName) : null;
    rootName = rootName != null ? rootName.object : void 0;
    root = modelToTree(model, {
      name: rootName,
      value: model
    });
    tree = root;
    items = descendants(elem, "[vf-model]");
    results = [];
    for (i = k = 0, ref = items.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      item = items[i];
      item.vfModel = vfModel = parse(item.getAttribute("vf-model"));
      vfModel.name = vfModel.list || vfModel.object || vfModel.atom;
      if (((vfModel.parent != null) && vfModel.parent !== rootName) || (vfModel.ancestors != null) || (vfModel.ancestorsList != null)) {
        if (vfModel.parent != null) {
          parent = tree;
          while (!!parent && parent.name !== vfModel.parent) {
            parent = parent.parent;
          }
          if (!parent) {
            continue;
          }
          value = parent.value[vfModel.name];
        } else {
          ancestorNames = vfModel.ancestors || vfModel.ancestorsList;
          parent = model;
          for (i = l = 0, len = ancestorNames.length; l < len; i = ++l) {
            ances = ancestorNames[i];
            parent = parent[ances];
            if (!parent) {
              break;
            }
          }
          if (!parent) {
            continue;
          }
          value = parent[vfModel.name];
        }
      } else {
        value = model[vfModel.name];
      }
      if (vfModel.object != null) {
        if (vfModel.parent != null) {
          parent = findParent(item, vfModel.parent, elem);
          if ((parent != null ? parent.vfModel.tree : void 0) != null) {
            results.push(vfModel.tree = tree = (ref1 = parent.vfModel.tree) != null ? ref1.children[vfModel.name] : void 0);
          } else {
            results.push(void 0);
          }
        } else {
          if (root.children[vfModel.name] != null) {
            results.push(vfModel.tree = tree = root.children[vfModel.name]);
          } else {
            results.push(void 0);
          }
        }
      } else if (typeof value !== 'undefined') {
        if (vfModel.list != null) {
          domRoot = vfModel.domRoot != null ? ancestor(item, vfModel.domRoot) : document;
          if (vfModel.clearElems != null) {
            elemsToClear = descendants(domRoot, vfModel.clearElems);
            for (m = 0, len1 = elemsToClear.length; m < len1; m++) {
              elemToClear = elemsToClear[m];
              elemToClear.remove();
            }
          }
          templ = descendant(domRoot, vfModel.itemTempl);
          results.push((function() {
            var len2, n, results1;
            results1 = [];
            for (n = 0, len2 = value.length; n < len2; n++) {
              childVal = value[n];
              itemElem = clone(templ, true);
              setModel(itemElem, childVal);
              itemElem.removeAttribute("id");
              itemElem.removeAttribute("vf-exclude");
              itemElem.style.display = '';
              results1.push(item.appendChild(itemElem));
            }
            return results1;
          })());
        } else {
          if (vfModel.setter != null) {
            results.push(eval(vfModel.setter).call(null, item, value));
          } else {
            results.push(val(item, value));
          }
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  doCreate = function(elem, createName) {
    var domRoot, model, target, template, vfCreate;
    vfCreate = parse(elem.getAttribute("vf-create"));
    domRoot = vfCreate.domRoot != null ? ancestor(elem, vfCreate.domRoot) : document;
    template = descendant(domRoot, vfCreate.templ);
    template = clone(template, true);
    template.removeAttribute("id");
    template.removeAttribute("vf-exclude");
    template.style.display = '';
    model = getModel(elem);
    setModel(template, model);
    if (vfCreate["append-to"] != null) {
      descendant(domRoot, vfCreate["append-to"]).appendChild(template);
    }
    if (vfCreate["insert-before"] != null) {
      target = descendant(domRoot, vfCreate["insert-before"]);
      target.parentNode.insertBefore(template, target);
    }
    if (vfCreate["src-set-after"] != null) {
      console.log(vfCreate["src-set-after"]);
      setModel(elem, vfCreate["src-set-after"]);
    }
    if (vfCreate["dest-set-after"] != null) {
      return setModel(template, vfCreate["dest-set-after"]);
    }
  };

  setUpListeners = function(root) {
    var i, item, items, k, ref, results, target, vfListen;
    items = descendants(root, "[vf-listen]");
    if (items.length === 0) {
      return;
    }
    results = [];
    for (i = k = 0, ref = items.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      item = items[i];
      vfListen = parse(item.getAttribute("vf-listen"));
      item.vfListen = vfListen;
      if (vfListen.action === "create") {
        target = ancestor(item, "[vf-create]");
        results.push(addListener(item, vfListen.on, target, function(e) {
          return doCreate(e.data);
        }));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  document.addEventListener("DOMContentLoaded", function() {
    return setUpListeners(document);
  });

  checkBoxListGet = function(elem) {
    var checkboxes, i, k, ref, result;
    result = [];
    checkboxes = descendants(elem, 'input[type="checkbox"]');
    for (i = k = 0, ref = checkboxes.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      elem = checkboxes[i];
      if (elem.checked && (elem.value != null)) {
        result.push(elem.value);
      }
    }
    return result;
  };

  checkBoxListSet = function(elem, vals) {
    var checkboxes, i, k, ref, results;
    vals = arrayToOdjectSet(vals);
    checkboxes = descendants(elem, 'input[type="checkbox"]');
    results = [];
    for (i = k = 0, ref = checkboxes.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      elem = checkboxes[i];
      results.push(elem.checked = vals[elem.value]);
    }
    return results;
  };

  checkBoxesGetBooleans = function(elem) {
    var checkboxes, i, k, ref, result;
    result = {};
    checkboxes = descendants(elem, 'input[type="checkbox"]');
    for (i = k = 0, ref = checkboxes.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      elem = checkboxes[i];
      result[elem.value] = elem.checked;
    }
    return result;
  };

  checkBoxesSetBooleansUpdate = function(elem, vals) {
    var checkboxes, i, k, ref, results;
    checkboxes = descendants(elem, 'input[type="checkbox"]');
    results = [];
    for (i = k = 0, ref = checkboxes.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      elem = checkboxes[i];
      if (vals[elem.value] != null) {
        results.push(elem.checked = vals[elem.value]);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  checkBoxesSetBooleans = function(elem, vals) {
    var checkboxes, i, k, ref, results;
    checkboxes = descendants(elem, 'input[type="checkbox"]');
    results = [];
    for (i = k = 0, ref = checkboxes.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      elem = checkboxes[i];
      results.push(elem.checked = !!vals[elem.value]);
    }
    return results;
  };

  bindFileInputToImg = function(imageInputElem, imgElem, extraAction) {
    return imageInputElem.addEventListener('change', function() {
      var reader;
      if (imageInputElem.files.length === 0) {
        val(imgElem, null);
        return;
      }
      imageInputElem.disabled = true;
      reader = new FileReader();
      reader.onload = function() {
        val(imgElem, reader.result);
        imageInputElem.disabled = false;
        if (typeof extraAction !== "undefined" && extraAction !== null) {
          return extraAction(reader.result);
        }
      };
      return reader.readAsDataURL(imageInputElem.files[0]);
    });
  };

  bindFileInputToLink = function(fileInputElem, linkElem) {
    return fileInputElem.addEventListener('change', function() {
      var reader;
      if (fileInputElem.files.length === 0) {
        elem.removeAttribute('href');
        elem.innerHTML = null;
        return;
      }
      fileInputElem.disabled = true;
      reader = new FileReader();
      reader.onload = function() {
        linkElem.href = reader.result;
        linkElem.innerHTML = fileInputElem.files[0].name;
        return fileInputElem.disabled = false;
      };
      return reader.readAsDataURL(fileInputElem.files[0]);
    });
  };

  selectListGet = function(elem) {
    var i, k, options, ref, result;
    result = [];
    options = descendants(elem, 'option:checked');
    for (i = k = 0, ref = options.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      result.push(options[i].value);
    }
    return result;
  };

  selectListSet = function(elem, vals) {
    var i, k, options, ref, results;
    vals = arrayToOdjectSet(vals);
    options = descendants(elem, 'option');
    if (options.length <= 0) {
      return;
    }
    results = [];
    for (i = k = 0, ref = options.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      elem = options[i];
      if ((vals[elem.value] != null) && vals[elem.value]) {
        results.push(elem.setAttribute('selected', 'true'));
      } else {
        results.push(elem.removeAttribute('selected'));
      }
    }
    return results;
  };

  fillSelectOptions = function(elems, options) {
    var elem, i, j, k, l, opt, optVal, ref, ref1, results, results1;
    if (!(elems instanceof Array) && !(elems instanceof NodeList)) {
      elems = [elems];
    }
    if (elems.length <= 0) {
      return;
    }
    if (options instanceof Array) {
      results = [];
      for (i = k = 0, ref = elems.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (j = l = 0, ref1 = options.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
            elem = document.createElement("option");
            elem.setAttribute("value", options[j]);
            elem.innerHTML = options[j];
            results1.push(elems[i].appendChild(elem));
          }
          return results1;
        })());
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, ref1 = elems.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
        results1.push((function() {
          var results2;
          results2 = [];
          for (opt in options) {
            if (!hasProp1.call(options, opt)) continue;
            optVal = options[opt];
            elem = document.createElement("option");
            elem.setAttribute("value", opt);
            elem.innerHTML = optVal;
            results2.push(elems[i].appendChild(elem));
          }
          return results2;
        })());
      }
      return results1;
    }
  };

  window.vf = {
    getModel: getModel,
    setModel: setModel,
    val: val,
    doCreate: doCreate,
    checkBoxListGet: checkBoxListGet,
    checkBoxListSet: checkBoxListSet,
    checkBoxesGetBooleans: checkBoxesGetBooleans,
    checkBoxesSetBooleans: checkBoxesSetBooleans,
    checkBoxesSetBooleansUpdate: checkBoxesSetBooleansUpdate,
    bindFileInputToImg: bindFileInputToImg,
    bindFileInputToLink: bindFileInputToLink,
    fillSelectOptions: fillSelectOptions,
    selectListGet: selectListGet,
    selectListSet: selectListSet
  };

}).call(this);

//# sourceMappingURL=vf.js.map
